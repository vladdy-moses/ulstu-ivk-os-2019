#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
//Лабораторная работа №3.2
//Создание нового процесса
//Выполнила студентка гр.ИСТбд-22 Гуськова Ю.А.
pid_t getpid(void);//получаем значение идентификатора текущего процесса
pid_t getppid(void);//получаем значение идентификатора родительского процесса для текущего процесса
int main()
{
    printf("Лабораторная работа №3.2\n");
    printf("Создание нового процесса\n");
    printf("Выполнила студентка гр.ИСТбд-22 Гуськова Ю.А.\n");
    printf("Задание: измените предыдущую программу с fork() так, чтобы родитель и ребенок совершали разные действия.\n");
    pid_t pid;//тип данных pid_t является синонимом для одного из целочисленных типов языка С
    pid_t ppid;
    int a = 0;
//процесс, который инициировал системный вызов fork, принято называть родительским процессом,
//а вновь порожденный процесс принято называть процессом-ребенком
//при успеном создани нового процесса с этого места псевдопараллельно начинают работать два процесса: старый и новый
   // (void)fork();
//Узнаем идентификаторы текущего и родительского процесса (в каждом из процессов)
    pid = getpid(); //присваиваем значениям переменных значения идентификаторов текущего
    ppid = getppid();//и родителького процессов
//процесc  определения, кто из них является ребенком, а кто родителем и
// системный вызов возвращает в них разные значения
    pid = fork();
    if (pid == 0)
        printf("This is the child\n");
    else
        printf("This is the parent\n");
//Перед выполнением следующего выражения значение переменной a в обоих процессах равно 0
    for (int i = 0; i<5; i++)
    {
        a++;
//Печатаем значения pid,ppid и вычисленное значение переменной a (в каждом из процессов)
    printf("My pid = %d, my ppid = %d, a = %d\n", (int)pid, (int)ppid, a);
    }
    return 0;
}
