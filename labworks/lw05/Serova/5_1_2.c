#include <stdlib.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <stdio.h>
#include <errno.h>
///Лабораторная работа №5, часть 1, программа 2
///Тема:Организация работы с разделяемой памятью.
///Задание: В разделяемой памяти размещается массив из трех целых чисел. Первый элемент
///массива используется как счетчик для программы 1, второй элемент – для
///программы 2, третий элемент – для обеих программ суммарно.
///Выполнила студентка группы ИСТбд-22 Серова В.И.
int main()
{
    printf("Выполнила студентка группы ИСТбд-22 Серова В.И.\n");
int *array; /* Указатель на разделяемую память */
int shmid; /* IPC дескриптор для области разделяемой памяти */
int ne = 1; /* Флаг необходимости инициализации элементов массива */
	char pathname[] = "/home/student/Documents/";
key_t key; /* IPC ключ */
/* Генерируем IPC */
// Функция ftok служит для преобразования имени существующего файла
// и небольшого целого числа, например, порядкового номера экземпляра
// средств связи, в ключ System V IPC.
// Параметр proj – это небольшое целое число, характеризующее экземп-
// ляр средства связи.
	/* Генерируем IPC ключ из имени файла и номера
экземпляра области разделяемой памяти 0 */
	if((key = ftok(pathname,0)) < 0){
		printf("Can\'t generate key\n");
		exit(-1);
	}
/* Создание разделяемой памяти */
// shmget — создает новый сегмент разделяемой памяти или находит существую-
// щий сегмент с тем же ключом;
// В качестве
// флагов поставляется комбинация прав доступа к создаваемому сегменту и
// флага IPC_CREAT. Если сегмент для данного ключа еще не существует, то
// система будет пытаться создать его с указанными правами доступа. Если же
// вдруг он уже существовал, то мы просто получим его дескриптор. Возможно
// добавление к этой комбинации флагов флага IPC_EXCL. Этот флаг гаранти-
// рует нормальное завершение системного вызова только в том случае, если
// сегмент действительно был создан (т. е. ранее он не существовал), если же
// сегмент существовал, то системный вызов завершится с ошибкой, и значение
// системной переменной errno, описанной в файле <errno.h>, будет установле-
// но в EEXIST.
	if((shmid = shmget(key, 3*sizeof(int),0666|IPC_CREAT|IPC_EXCL)) < 0){
/* Анализ ошибки создания*/
if(errno != EEXIST){ /*прочие ошибки*/
		printf("Can\'t create shared memory\n");
		exit(-1);
} else {
		/* Если разделяемая память уже
существует, то пытаемся получить ее IPC
дескриптор и, в случае удачи, сбрасываем флаг
необходимости инициализации элементов массива */
		if((shmid = shmget(key, 3*sizeof(int), 0)) < 0){
			printf("Can\'t find shared memory\n");
			exit(-1);
		}
		ne = 0;
	}
}
/*Отображение разделяемой памяти в адресное пространство текущего
процесса. Обратите внимание на то, что для правильного сравнения мы яв-
но преобразовываем значение -1 к указателю на целое.*/
if((array = (int *)shmat(shmid, NULL, 0)) == (int *)(-1)){
	printf("Can't attach shared memory\n");
	exit(-1);
}
/* В зависимости от значения флага new либо инициализируем массив, ли-
бо увеличиваем соответствующие счетчики */
if(ne){
	array[0] = 0;
	array[1] = 1;
	array[2] = 1;
} else {
	array[1] += 1;
	array[2] += 1;
}
/* Печатаем новые значения счетчиков, удаляем разделяемую память из
адресного пространства текущего процесса и завершаем работу */
printf("Program 1 was spawn %d times, program 2 - %d times, total - %d times\n",array[0], array[1], array[2]);
if(shmdt(array) < 0){
	printf("Can't detach shared memory\n");
	exit(-1);
}
return 0;
}
