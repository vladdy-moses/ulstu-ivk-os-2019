#include <stdlib.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <stdio.h>
#include <errno.h>
///Лабораторная работа №5 часть 1, программа 1
///Тема:Организация работы с разделяемой памятью.
///Задание: В разделяемой памяти размещается массив из трех целых чисел. Первый элемент
///массива используется как счетчик для программы 1, второй элемент – для
///программы 2, третий элемент – для обеих программ суммарно.
///Выполнила студентка группы ИСТбд-22 Серова В.И.
int main()
{
    printf("Выполнила студентка группы ИСТбд-22 Серова В.И.\n");
int *array; /* Указатель на разделяемую память */
int shmid; /* IPC дескриптор для области разделяемой памяти */
// new используется для инициализации массива и сохранения данных
int new = 1; /* Флаг необходимости инициализации элементов массива */
char pathname[] = "/home/student/Documents/"; /* Имя файла, используемое для генерации ключа.
Файл с таким именем должен существовать в текущей директории */
key_t key; /* IPC ключ */
/* Генерируем IPC ключ из имени файла 1.c в текущей директории и номера
экземпляра области разделяемой памяти 0 */
	if((key = ftok(pathname,0)) < 0){
		printf("Can\'t generate key\n");
		exit(-1);
	}
/* Пытаемся эксклюзивно создать разделяемую память для сгенерированно-
го ключа, т.е. если для этого ключа она уже существует, системный вызов
вернет отрицательное значение. Размер памяти определяем как размер
массива из трех целых переменных, права доступа 0666 – чтение и запись
разрешены для всех */
	if((shmid = shmget(key, 3*sizeof(int), 0666|IPC_CREAT|IPC_EXCL)) < 0) {
/* В случае ошибки пытаемся определить: возникла ли она из-за того, что
сегмент разделяемой памяти уже существует или по другой причине */
		if(errno != EEXIST){
/* Если по другой причине – прекращаем работу */
			printf("Can\'t create shared memory\n");
			exit(-1);
		} else {
/* Если из-за того, что разделяемая память уже
существует, то пытаемся получить ее IPC
дескриптор и, в случае удачи, сбрасываем флаг
необходимости инициализации элементов массива */
			if((shmid = shmget(key, 3*sizeof(int), 0)) < 0){
				printf("Can\'t find shared memory\n");
				exit(-1);
			}
			new = 0;
		}
	}
/* Пытаемся отобразить разделяемую память в адресное пространство
текущего процесса. Обратите внимание на то, что для правильного сравне-
ния мы явно преобразовываем значение -1 к указателю на целое.*/
	if((array = (int *)shmat(shmid, NULL, 0)) == (int *)(-1)){
		printf("Can\'t attach shared memory\n");
		exit(-1);
	}
/* В зависимости от значения флага new либо
инициализируем массив, либо увеличиваем
соответствующие счетчики */
	if(new){
		array[0] = 1;
		array[1] = 0;
		array[2] = 1;
	}
	else {
		array[0] += 1;
		array[2] += 1;
	}
/* Печатаем новые значения счетчиков, удаляем разделяемую память из ад-
ресного пространства текущего процесса и завершаем работу */
	printf("Program 1 was spawn %d times, program 2 - %d times, total - %d times\n", array[0], array[1], array[2]);
	if (shmdt(array) < 0){
		printf("Can\'t detach shared memory\n");
		exit(-1);
	}
	return 0;
}
