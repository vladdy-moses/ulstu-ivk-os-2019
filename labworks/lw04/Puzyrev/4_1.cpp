#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
///Лабораторная работа №4.1
///Тема:Потоковое межпроцессное взаимодействие.Межпроцессное взаимодействие через канал pipe.
///Задание: модифицируйте пример для связи между собой двух
///родственных процессов, исполняющих разные программы.
///Выполнил студент группы ИСТбд-21 Пузырев И.И.

using namespace std;

///pipe имеет и другое название – именованный канал.
///Pipe представляет собой область памяти, недоступную пользовательским
///процессам напрямую, зачастую организованную в виде кольцевого буфера.
int main()
{
    printf("Выполнил студент группы ИСТбд-21 Пузырев И.И\n");
	int fd[2], result;
	size_t size;
	char string[] = "Hello, world!";///Строка для записи
	char resstring[14];///Строка для чтения
	int er=pipe(fd);   /// Создаём канал с двумя файловыми дескрипторами - потоки ввода и вывода
    if (er==0)         ///ошибка -1 ,0 при нормальном исполнении
    {                  ///fd[0]-дескриптор, соответствующий входному потоку данных
                       ///канала и позволяющий выполнять только операцию чтения,
                       ///fd[1]) будет занесен файловый дескриптор, соответствующий
                     ///выходному потоку данных и позволяющий выполнять только операцию записи
        result = fork(); /// Порождаем дочерний процесс
        if (result > 0)
        {
            printf("Работу начал родительский процесс\n");
            /// Родитель записывает строку в канал через входной поток
            close(fd[0]); /// Входной поток родителя закрываем
            printf("Начали запись строки...\n");
            size = write(fd[1],string, 14); ///Запись всей строки вместе с признаком конца строки в канал
            printf("Записали строку...\n");
            close(fd[1]); /// Выходной поток закрываем
            ///Если есть процессы, у которых этот pipe открыт для записи, то системный вызов read блокируется и
            ///ждет появления информации.
            printf("Закрыли выходной поток! \n");
        }
        else
         {
            printf("Работу начал дочерний процесс\n");
            /// Потомок читает строку из канала через входной поток
            close(fd[1]); /// Выходной поток закрываем
            printf("Начали чтение строки...\n");
            size = read(fd[0], resstring, 14); /// Если читается из пустого канала, то процесс блокируется(write,read - блокирующие системные вызовы)
            printf("Прочитали строку...\n");
            printf("Прочитанная строка: \n");
            printf("%s\n", resstring);/// Печать прочитанной строки
            close(fd[0]); /// Входной поток закрываем
            printf("Закрыли входной поток! \n");
         }
	}
	else printf("Ошибка создания канала...\n");
    return 0;
    ///Когда все процессы, использующие pipe,закрывают все ассоциированные с ним файловые дескрипторы, операцион-
    ///ная система ликвидирует pipe.
}
